<!-- @format -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gesture-Based Particle System + Gemini AI</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Three.js & Post Processing -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <!-- MediaPipe Hands -->
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #050505;
        font-family: "Inter", sans-serif;
      }
      canvas {
        display: block;
      }

      /* Glassmorphism UI */
      .glass-panel {
        background: rgba(20, 20, 25, 0.7);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
      }

      #loading-overlay {
        transition: opacity 0.5s ease;
      }

      .camera-feed {
        transform: scaleX(-1); /* Mirror camera */
        opacity: 0.3;
        transition: opacity 0.3s;
      }
      .camera-feed:hover {
        opacity: 1;
      }

      /* AI Prompt Modal */
      .ai-modal {
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
          opacity 0.3s ease;
        transform: scale(0.95);
        opacity: 0;
        pointer-events: none;
      }
      .ai-modal.active {
        transform: scale(1);
        opacity: 1;
        pointer-events: auto;
      }
    </style>
  </head>
  <body class="text-white">
    <!-- Loading Overlay -->
    <div
      id="loading-overlay"
      class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black"
    >
      <div
        class="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"
      ></div>
      <h2 class="text-xl font-light tracking-widest text-blue-400">
        LOADING ASSETS
      </h2>
      <p class="text-xs text-gray-500 mt-2">Loading Fonts & MediaPipe...</p>
    </div>

    <!-- UI Overlay -->
    <div
      class="absolute inset-0 pointer-events-none z-10 flex flex-col justify-between p-6"
    >
      <!-- Top Bar: Header & Stats -->
      <div class="flex justify-between items-start">
        <div class="pointer-events-auto">
          <h1
            class="text-2xl font-bold tracking-tighter bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500"
          >
            AETHER<span class="text-white font-light opacity-50"
              >.PARTICLES</span
            >
          </h1>
          <p class="text-xs text-gray-400 mt-1 max-w-[200px]">
            <span
              class="inline-block w-2 h-2 rounded-full bg-green-500 mr-1 animate-pulse"
              id="status-dot"
            ></span>
            <span id="status-text">Waiting for camera...</span>
          </p>
          <div
            id="gesture-detected"
            class="mt-2 text-sm font-bold text-yellow-400 h-6"
          ></div>
        </div>

        <!-- Webcam Preview (Enlarged) -->
        <div
          class="pointer-events-auto glass-panel rounded-lg p-1 w-64 h-48 overflow-hidden relative group"
        >
          <video
            id="input-video"
            class="w-full h-full object-cover rounded camera-feed"
            playsinline
          ></video>
          <div
            class="absolute inset-0 flex items-center justify-center pointer-events-none group-hover:hidden"
          >
            <i data-lucide="camera" class="w-6 h-6 text-white opacity-50"></i>
          </div>
        </div>
      </div>

      <!-- Right Side: Controls -->
      <div
        class="absolute top-1/2 right-6 transform -translate-y-1/2 pointer-events-auto flex flex-col gap-4 items-end"
      >
        <div
          class="glass-panel p-4 rounded-2xl flex flex-col gap-4 w-16 items-center"
        >
          <!-- Color Picker -->
          <div class="relative group" title="Base Color">
            <input type="color" id="color-picker" value="#4f90ff" />
          </div>

          <div class="w-8 h-[1px] bg-white/10"></div>

          <!-- Fullscreen -->
          <button
            id="btn-fullscreen"
            class="p-2 rounded-full hover:bg-white/10 text-white/70 hover:text-white transition-colors"
            title="Toggle Fullscreen"
          >
            <i data-lucide="maximize" class="w-5 h-5"></i>
          </button>
        </div>

        <!-- AI Magic Button -->
        <button
          id="btn-ai-toggle"
          class="glass-panel p-3 rounded-full hover:bg-white/20 text-purple-400 hover:text-purple-300 transition-all shadow-lg shadow-purple-900/20 group relative"
        >
          <i data-lucide="sparkles" class="w-6 h-6 animate-pulse"></i>
          <span
            class="absolute right-full mr-4 bg-black/80 px-2 py-1 rounded text-xs whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none"
          >
            AI Magic
          </span>
        </button>
      </div>

      <!-- Bottom Bar: Instructions -->
      <div class="flex justify-center w-full pointer-events-auto pb-4">
        <div
          class="glass-panel px-6 py-3 rounded-full flex gap-6 items-center text-xs text-gray-300"
        >
          <div class="flex items-center gap-2">
            <i data-lucide="hand" class="w-4 h-4 text-blue-400"></i> Open:
            Colorful
          </div>
          <div class="flex items-center gap-2">
            <i data-lucide="grab" class="w-4 h-4 text-yellow-600"></i> Fist:
            Saturn
          </div>
          <div class="flex items-center gap-2">
            <i data-lucide="scissors" class="w-4 h-4 text-yellow-400"></i>
            V-Sign: Text
          </div>
          <div class="flex items-center gap-2">
            <i data-lucide="heart" class="w-4 h-4 text-pink-400"></i> Pinch:
            Love
          </div>
        </div>
      </div>
    </div>

    <!-- AI Prompt Modal -->
    <div
      id="ai-modal"
      class="ai-modal fixed inset-0 z-40 flex items-center justify-center bg-black/60 backdrop-blur-sm"
    >
      <div
        class="glass-panel p-6 rounded-2xl w-full max-w-md mx-4 shadow-2xl border border-purple-500/30"
      >
        <div class="flex justify-between items-center mb-4">
          <h3
            class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-purple-400 to-pink-400 flex items-center gap-2"
          >
            <i data-lucide="sparkles" class="w-5 h-5 text-purple-400"></i>
            AI Magic Generator
          </h3>
          <button id="btn-close-ai" class="text-gray-400 hover:text-white">
            <i data-lucide="x" class="w-5 h-5"></i>
          </button>
        </div>
        <p class="text-sm text-gray-400 mb-4">
          Describe a shape or a color mood. Gemini will write the math to
          generate it.
        </p>

        <textarea
          id="ai-prompt-input"
          rows="3"
          class="w-full bg-black/50 border border-gray-700 rounded-lg p-3 text-sm focus:outline-none focus:border-purple-500 transition-colors resize-none text-white mb-4"
          placeholder="e.g., 'Double helix DNA' or 'Cyberpunk Neon colors'..."
        ></textarea>

        <div class="flex gap-3">
          <button
            id="btn-generate-shape"
            class="flex-1 py-3 rounded-lg bg-gradient-to-r from-purple-600 to-purple-800 hover:from-purple-500 hover:to-purple-700 font-bold shadow-lg transform active:scale-95 transition-all flex justify-center items-center gap-2"
          >
            <i data-lucide="box" class="w-4 h-4"></i>
            <span>Generate Shape</span>
          </button>
          <button
            id="btn-generate-color"
            class="flex-1 py-3 rounded-lg bg-gradient-to-r from-blue-600 to-cyan-600 hover:from-blue-500 hover:to-cyan-500 font-bold shadow-lg transform active:scale-95 transition-all flex justify-center items-center gap-2"
          >
            <i data-lucide="palette" class="w-4 h-4"></i>
            <span>Paint Colors</span>
          </button>
        </div>
        <p
          id="ai-status"
          class="text-center text-xs text-gray-500 mt-2 h-4"
        ></p>
      </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      // Import MeshSurfaceSampler for uniform particle distribution on text
      import { MeshSurfaceSampler } from "three/addons/math/MeshSurfaceSampler.js";

      // Initialize Icons
      lucide.createIcons();

      // Gemini Configuration
      const apiKey = ""; // Set by environment
      const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

      // Global State
      const state = {
        currentShape: "sphere",
        handOpenness: 1,
        targetHandOpenness: 1,
        baseColor: new THREE.Color("#4f90ff"),
        particleCount: 20000,
        isTracking: false,
        gesture: "none",
        font: null,
        // Tracking state
        handPosition: { x: 0, y: 0 },
        targetHandPosition: { x: 0, y: 0 },
        // AI State
        customShapeCode: null,
        aiDescription: "",
      };

      const loadingOverlay = document.getElementById("loading-overlay");
      const statusText = document.getElementById("status-text");
      const gestureText = document.getElementById("gesture-detected");

      // --- PRELOAD ASSETS (Font only) ---
      const loadAssets = async () => {
        const loader = new FontLoader();

        // Load Font
        loader.load(
          "https://threejs.org/examples/fonts/helvetiker_bold.typeface.json",
          (font) => {
            state.font = font;
            loadingOverlay.style.opacity = "0";
            setTimeout(() => (loadingOverlay.style.display = "none"), 500);
            statusText.innerText = "System Ready. Show Hand.";
          }
        );
      };

      loadAssets();

      // --- THREE.JS SETUP ---
      const container = document.getElementById("canvas-container");
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050505, 0.002);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 35;

      const renderer = new THREE.WebGLRenderer({
        antialias: false,
        powerPreference: "high-performance",
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      // --- POST PROCESSING (BLOOM) ---
      const renderScene = new RenderPass(scene, camera);
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5,
        0.4,
        0.85
      );
      bloomPass.threshold = 0;
      bloomPass.strength = 1.0;
      bloomPass.radius = 0.5;

      const composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      // --- PARTICLE SYSTEM ENGINE ---
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(state.particleCount * 3);
      const targetPositions = new Float32Array(state.particleCount * 3);
      const colors = new Float32Array(state.particleCount * 3);
      const targetColors = new Float32Array(state.particleCount * 3);
      const randomOffsets = new Float32Array(state.particleCount * 3);

      // Initialize particles
      for (let i = 0; i < state.particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

        colors[i * 3] = state.baseColor.r;
        colors[i * 3 + 1] = state.baseColor.g;
        colors[i * 3 + 2] = state.baseColor.b;

        targetColors[i * 3] = state.baseColor.r;
        targetColors[i * 3 + 1] = state.baseColor.g;
        targetColors[i * 3 + 2] = state.baseColor.b;

        // Dispersion noise
        const r = 40;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        randomOffsets[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        randomOffsets[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        randomOffsets[i * 3 + 2] = r * Math.cos(phi);
      }

      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const sprite = new THREE.TextureLoader().load(
        "https://threejs.org/examples/textures/sprites/disc.png"
      );

      const material = new THREE.PointsMaterial({
        vertexColors: true, // Enable individual particle colors
        size: 0.4,
        sizeAttenuation: true,
        map: sprite,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // --- SHAPE GENERATORS ---

      function generateTargetShape(type) {
        if (
          state.currentShape === type &&
          type !== "rainbow_sphere" &&
          type !== "ai_custom"
        ) {
          return;
        }
        state.currentShape = type;
        const count = state.particleCount;

        if (type === "ai_custom" && state.customShapeCode) {
          try {
            const generator = new Function(
              "count",
              "targetPositions",
              "targetColors",
              "Math",
              state.customShapeCode
            );
            generator(count, targetPositions, targetColors, Math);
          } catch (e) {
            console.error("AI Code Error:", e);
            generateTargetShape("rainbow_sphere");
          }
        } else if (type === "text" && state.font) {
          // 1. TEXT: "I LOVE YOU" (3D with Surface Sampling)
          const textGeo = new TextGeometry("I LOVE YOU", {
            font: state.font,
            size: 3.5,
            height: 1.5, // 3D Thickness
            curveSegments: 6,
            bevelEnabled: true,
            bevelThickness: 0.1,
            bevelSize: 0.05,
            bevelSegments: 3,
          });
          textGeo.center();

          // Create a temporary mesh to sample from
          const textMesh = new THREE.Mesh(textGeo);

          // Use MeshSurfaceSampler to distribute points uniformly on the surface
          const sampler = new MeshSurfaceSampler(textMesh).build();
          const tempPosition = new THREE.Vector3();

          for (let i = 0; i < count; i++) {
            const i3 = i * 3;

            // Sample a point from the text surface
            sampler.sample(tempPosition);

            // Scale it up
            targetPositions[i3] = tempPosition.x * 1.5;
            targetPositions[i3 + 1] = tempPosition.y * 1.5;
            targetPositions[i3 + 2] = tempPosition.z * 1.5;

            // Color: Gold/Yellow with slight variation for sparkle
            targetColors[i3] = 1.0;
            targetColors[i3 + 1] = 0.8 + Math.random() * 0.2;
            targetColors[i3 + 2] = 0.1;
          }
        } else if (type === "saturn") {
          // 2. SATURN (Fist Gesture)
          const planetRadius = 7;
          const ringInner = 10;
          const ringOuter = 16;

          const planetParticleCount = Math.floor(count * 0.4);

          for (let i = 0; i < count; i++) {
            const i3 = i * 3;

            if (i < planetParticleCount) {
              // PLANET BODY
              const phi = Math.acos(-1 + (2 * i) / planetParticleCount);
              const theta = Math.sqrt(planetParticleCount * Math.PI) * phi;

              targetPositions[i3] =
                planetRadius * Math.cos(theta) * Math.sin(phi);
              targetPositions[i3 + 1] =
                planetRadius * Math.sin(theta) * Math.sin(phi);
              targetPositions[i3 + 2] = planetRadius * Math.cos(phi);

              // Color: Blue Planet
              targetColors[i3] = 0.1;
              targetColors[i3 + 1] = 0.4;
              targetColors[i3 + 2] = 0.9;
            } else {
              // RINGS
              const t = Math.random() * Math.PI * 2;
              const r = ringInner + Math.random() * (ringOuter - ringInner);

              targetPositions[i3] = r * Math.cos(t);
              targetPositions[i3 + 1] = (Math.random() - 0.5) * 0.3; // Flat
              targetPositions[i3 + 2] = r * Math.sin(t);

              // TILT the ring points locally
              const x = targetPositions[i3];
              const y = targetPositions[i3 + 1];
              const z = targetPositions[i3 + 2];

              // Rotate around X axis ~20deg
              const angle = 0.4;
              targetPositions[i3 + 1] =
                y * Math.cos(angle) - z * Math.sin(angle);
              targetPositions[i3 + 2] =
                y * Math.sin(angle) + z * Math.cos(angle);

              // Color: Ring Dust (Beige)
              targetColors[i3] = 0.8;
              targetColors[i3 + 1] = 0.8;
              targetColors[i3 + 2] = 0.7;
            }
          }
        } else if (type === "heart") {
          // 3. HEART (Pinch Gesture)
          const scale = 0.8; // Smaller scale for finger heart
          for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            const t = Math.random() * Math.PI * 2;

            // Parametric Heart
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y =
              13 * Math.cos(t) -
              5 * Math.cos(2 * t) -
              2 * Math.cos(3 * t) -
              Math.cos(4 * t);
            let z = (Math.random() - 0.5) * 5;

            x *= scale;
            y *= scale;
            z *= scale;

            targetPositions[i3] = x;
            targetPositions[i3 + 1] = y;
            targetPositions[i3 + 2] = z;

            // Color: Hot Pink
            targetColors[i3] = 1.0;
            targetColors[i3 + 1] = 0.1;
            targetColors[i3 + 2] = 0.6;
          }
        } else {
          // 4. RAINBOW SPHERE (Open Hand)
          const r = 25;
          for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            targetPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
            targetPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            targetPositions[i3 + 2] = r * Math.cos(phi);

            // RAINBOW
            const color = new THREE.Color();
            color.setHSL(Math.random(), 1.0, 0.6);

            targetColors[i3] = color.r;
            targetColors[i3 + 1] = color.g;
            targetColors[i3 + 2] = color.b;
          }
        }
      }

      // Initialize
      generateTargetShape("rainbow_sphere");

      // --- ANIMATION LOOP ---
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // 1. Hand Position Smoothing (Smooth Damping)
        state.handPosition.x +=
          (state.targetHandPosition.x - state.handPosition.x) * 0.1;
        state.handPosition.y +=
          (state.targetHandPosition.y - state.handPosition.y) * 0.1;

        // 2. Move Particle System to Hand Position (Only if gesture active)
        let targetGroupX = 0;
        let targetGroupY = 0;

        if (state.gesture === "fist" || state.gesture === "pinch") {
          targetGroupX = state.handPosition.x;
          targetGroupY = state.handPosition.y;
        }

        particles.position.x += (targetGroupX - particles.position.x) * 0.08;
        particles.position.y += (targetGroupY - particles.position.y) * 0.08;

        // 3. Hand Openness
        state.handOpenness +=
          (state.targetHandOpenness - state.handOpenness) * 0.1;

        const positionsAttribute = particles.geometry.attributes.position;
        const colorsAttribute = particles.geometry.attributes.color;
        const currentPos = positionsAttribute.array;
        const currentCol = colorsAttribute.array;

        // 4. Rotation Logic
        if (state.currentShape === "saturn") {
          particles.rotation.z = 0.2;
          particles.rotation.y += 0.01;
        } else if (state.currentShape === "heart") {
          particles.rotation.y = Math.sin(time) * 0.2;
          particles.rotation.z = 0;
        } else if (state.currentShape === "text") {
          // Text: Slow pan to read clearly
          particles.rotation.z = 0;
          particles.rotation.y = Math.sin(time * 0.3) * 0.15;
        } else if (state.currentShape === "ai_custom") {
          particles.rotation.z = 0;
          particles.rotation.y += 0.005;
        } else {
          particles.rotation.z = 0;
          particles.rotation.y = Math.sin(time * 0.1) * 0.3;
        }

        const lerpSpeed = 0.08;

        let dispersion = 0;
        if (state.gesture === "open") {
          dispersion = 30 * state.handOpenness;
        }

        for (let i = 0; i < state.particleCount; i++) {
          const i3 = i * 3;

          const tx = targetPositions[i3];
          const ty = targetPositions[i3 + 1];
          const tz = targetPositions[i3 + 2];

          // Noise
          const noiseX = Math.sin(time * 2.0 + i) * dispersion;
          const noiseY = Math.cos(time * 2.0 + i * 0.9) * dispersion;
          const noiseZ = Math.sin(time * 2.0 + i * 1.2) * dispersion;

          let destX = tx;
          let destY = ty;
          let destZ = tz;

          if (dispersion > 1) {
            destX += randomOffsets[i3] * 0.5 + noiseX;
            destY += randomOffsets[i3 + 1] * 0.5 + noiseY;
            destZ += randomOffsets[i3 + 2] * 0.5 + noiseZ;
          }

          currentPos[i3] += (destX - currentPos[i3]) * lerpSpeed;
          currentPos[i3 + 1] += (destY - currentPos[i3 + 1]) * lerpSpeed;
          currentPos[i3 + 2] += (destZ - currentPos[i3 + 2]) * lerpSpeed;

          // Color Lerp
          currentCol[i3] += (targetColors[i3] - currentCol[i3]) * 0.05;
          currentCol[i3 + 1] +=
            (targetColors[i3 + 1] - currentCol[i3 + 1]) * 0.05;
          currentCol[i3 + 2] +=
            (targetColors[i3 + 2] - currentCol[i3 + 2]) * 0.05;
        }

        positionsAttribute.needsUpdate = true;
        colorsAttribute.needsUpdate = true;
        composer.render();
      }

      animate();

      // --- GEMINI AI INTEGRATION ---

      async function callGemini(prompt, mode = "shape") {
        let systemPrompt = "";

        if (mode === "shape") {
          systemPrompt = `
                    You are a JavaScript Graphics Programmer for a Three.js Particle System.
                    Write the body of a JavaScript loop to position particles based on the user's description.
                    
                    Context:
                    - 'count' (integer, ~20000)
                    - 'targetPositions' (Float32Array, x=i*3, y=i*3+1, z=i*3+2)
                    - 'Math' is available.
                    - Scale roughly 20-30 units.
                    
                    Output JSON: { "code": "for(let i=0; i<count; i++) { ... }" }
                `;
        } else {
          systemPrompt = `
                    You are a JavaScript Colorist for a Particle System.
                    Write a JS loop to set 'targetColors' (Float32Array, r=i*3, g=i*3+1, b=i*3+2) based on the description.
                    RGB values must be 0.0 to 1.0.
                    
                    Context:
                    - 'count' (integer)
                    - 'targetColors' (Float32Array)
                    - 'targetPositions' (Float32Array, read-only if needed for position-based coloring)
                    - 'Math'
                    
                    Output JSON: { "code": "for(let i=0; i<count; i++) { ... }" }
                `;
        }

        const fullPrompt = `Create a particle system ${mode} for: "${prompt}"`;

        try {
          const response = await fetch(GEMINI_API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [{ parts: [{ text: fullPrompt }] }],
              systemInstruction: { parts: [{ text: systemPrompt }] },
              generationConfig: { responseMimeType: "application/json" },
            }),
          });

          if (!response.ok) throw new Error("API Error");

          const data = await response.json();
          const jsonText = data.candidates[0].content.parts[0].text;
          const result = JSON.parse(jsonText);
          return result.code;
        } catch (error) {
          console.error("Gemini Error:", error);
          return null;
        }
      }

      // AI UI Handlers
      const modal = document.getElementById("ai-modal");
      const btnAiToggle = document.getElementById("btn-ai-toggle");
      const btnCloseAi = document.getElementById("btn-close-ai");
      const btnGenerateShape = document.getElementById("btn-generate-shape");
      const btnGenerateColor = document.getElementById("btn-generate-color");
      const aiStatus = document.getElementById("ai-status");
      const promptInput = document.getElementById("ai-prompt-input");

      btnAiToggle.addEventListener("click", () => {
        modal.classList.add("active");
        promptInput.focus();
      });

      const closeModal = () => modal.classList.remove("active");
      btnCloseAi.addEventListener("click", closeModal);
      modal.addEventListener("click", (e) => {
        if (e.target === modal) closeModal();
      });

      async function handleGeneration(mode) {
        const prompt = promptInput.value.trim();
        if (!prompt) return;

        const btn = mode === "shape" ? btnGenerateShape : btnGenerateColor;
        const originalText = btn.innerHTML;

        // Disable UI
        btnGenerateShape.disabled = true;
        btnGenerateColor.disabled = true;
        btn.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i> Generating...`;
        aiStatus.innerText = "Gemini is dreaming...";
        aiStatus.className =
          "text-center text-xs text-purple-400 mt-2 h-4 animate-pulse";

        const code = await callGemini(prompt, mode);

        if (code) {
          if (mode === "shape") {
            state.customShapeCode = code;
            state.aiDescription = prompt;

            state.targetHandOpenness = 0;
            state.gesture = "none";
            gestureText.innerText =
              "AI Shape: " + prompt.substring(0, 15) + "...";
            gestureText.className =
              "mt-2 text-sm font-bold text-purple-400 h-6";

            generateTargetShape("ai_custom");
          } else {
            // COLOR MODE
            // Execute immediately to update targetColors
            try {
              const colorizer = new Function(
                "count",
                "targetColors",
                "targetPositions",
                "Math",
                code
              );
              colorizer(
                state.particleCount,
                targetColors,
                targetPositions,
                Math
              );

              gestureText.innerText =
                "AI Color: " + prompt.substring(0, 15) + "...";
              gestureText.className =
                "mt-2 text-sm font-bold text-blue-400 h-6";
            } catch (e) {
              console.error("Color Code Error", e);
            }
          }
          closeModal();
          promptInput.value = "";
        } else {
          aiStatus.innerText = "Failed to generate. Try again.";
          aiStatus.className = "text-center text-xs text-red-500 mt-2 h-4";
        }

        btnGenerateShape.disabled = false;
        btnGenerateColor.disabled = false;
        btnGenerateShape.innerHTML = `<i data-lucide="box" class="w-4 h-4"></i> <span>Generate Shape</span>`;
        btnGenerateColor.innerHTML = `<i data-lucide="palette" class="w-4 h-4"></i> <span>Paint Colors</span>`;
        lucide.createIcons();
      }

      btnGenerateShape.addEventListener("click", () =>
        handleGeneration("shape")
      );
      btnGenerateColor.addEventListener("click", () =>
        handleGeneration("color")
      );

      // --- GESTURE RECOGNITION (REFINED) ---

      function detectGesture(landmarks) {
        const wrist = landmarks[0];
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const indexMcp = landmarks[5];
        const middleTip = landmarks[12];
        const middleMcp = landmarks[9];
        const ringTip = landmarks[16];
        const ringMcp = landmarks[13];
        const pinkyTip = landmarks[20];
        const pinkyMcp = landmarks[17];

        const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);

        const isFolded = (tip, mcp) => {
          const dTipWrist = dist(tip, wrist);
          const dMcpWrist = dist(mcp, wrist);
          return dTipWrist < dMcpWrist || dist(tip, mcp) < 0.1;
        };

        const indexFolded = isFolded(indexTip, indexMcp);
        const middleFolded = isFolded(middleTip, middleMcp);
        const ringFolded = isFolded(ringTip, ringMcp);
        const pinkyFolded = isFolded(pinkyTip, pinkyMcp);

        // 1. FIST (Saturn)
        if (indexFolded && middleFolded && ringFolded && pinkyFolded) {
          return "fist";
        }

        // 2. PINCH (Finger Heart)
        const pinchDist = dist(thumbTip, indexTip);
        const othersDown = middleFolded && ringFolded && pinkyFolded;

        // Allow wider/looser hearts (threshold 0.18)
        if (othersDown && pinchDist < 0.18) {
          return "pinch";
        }

        // 3. V-SIGN
        const spread = dist(indexTip, middleTip);
        if (
          !indexFolded &&
          !middleFolded &&
          ringFolded &&
          pinkyFolded &&
          spread > 0.1
        ) {
          return "victory";
        }

        // 4. OPEN
        if (!indexFolded && !middleFolded && !ringFolded) {
          return "open";
        }

        return "neutral";
      }

      function onResults(results) {
        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length > 0
        ) {
          const landmarks = results.multiHandLandmarks[0];

          // Track Hand
          const palmX = landmarks[9].x;
          const palmY = landmarks[9].y;
          const rangeX = 35;
          const rangeY = 25;
          const worldX = (0.5 - palmX) * rangeX * 2;
          const worldY = (0.5 - palmY) * rangeY * 2;
          state.targetHandPosition.x = worldX;
          state.targetHandPosition.y = worldY;

          const gesture = detectGesture(landmarks);
          state.gesture = gesture;
          state.statusDot = document.getElementById("status-dot");
          state.statusDot.className =
            "inline-block w-2 h-2 rounded-full bg-green-500 mr-1 animate-pulse";

          if (gesture !== "neutral") {
            if (gesture === "fist") {
              gestureText.innerText = "Gesture: Fist (Saturn)";
              gestureText.className =
                "mt-2 text-sm font-bold text-yellow-600 h-6";
              state.targetHandOpenness = 0;
              generateTargetShape("saturn");
            } else if (gesture === "victory") {
              gestureText.innerText = "Gesture: V-Sign (I LOVE YOU)";
              gestureText.className =
                "mt-2 text-sm font-bold text-yellow-400 h-6";
              state.targetHandOpenness = 0.2;
              generateTargetShape("text");
            } else if (gesture === "pinch") {
              gestureText.innerText = "Gesture: Finger Heart";
              gestureText.className =
                "mt-2 text-sm font-bold text-pink-500 h-6";
              state.targetHandOpenness = 0;
              generateTargetShape("heart");
            } else if (gesture === "open") {
              gestureText.innerText = "Gesture: Open (Rainbow)";
              gestureText.className =
                "mt-2 text-sm font-bold text-blue-400 h-6";
              state.targetHandOpenness = 1;
              generateTargetShape("rainbow_sphere");
            }
          } else {
            if (state.currentShape !== "ai_custom") {
              gestureText.innerText = "Gesture: Neutral";
              gestureText.className =
                "mt-2 text-sm font-bold text-gray-500 h-6";
            }
          }
        } else {
          state.gesture = "none";
          gestureText.innerText = "No Hand Detected";
        }
      }

      const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        },
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.6,
      });

      hands.onResults(onResults);

      const videoElement = document.getElementById("input-video");
      const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480,
      });

      cameraUtils.start();

      document.getElementById("color-picker").addEventListener("input", (e) => {
        state.baseColor.set(e.target.value);
      });

      document
        .getElementById("btn-fullscreen")
        .addEventListener("click", async () => {
          try {
            if (!document.fullscreenElement) {
              await document.documentElement.requestFullscreen();
            } else {
              if (document.exitFullscreen) await document.exitFullscreen();
            }
          } catch (e) {
            console.warn("Fullscreen error:", e);
            alert("Fullscreen not allowed in this mode.");
          }
        });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
